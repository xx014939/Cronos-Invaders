<!DOCTYPE html>
<html>
  <head>
    <title>Socket.IO</title>
    <style>
      canvas {
        border:1px solid #d3d3d3;
        background-color: #f1f1f1;
      }
</style>
    </style>
  </head>
  <body>
    <script src="/socket.io/socket.io.js"></script>
  </body>
</html>

<script>

let socket = io();
let allPlayerObjects = [];
let clientSideBulletArray = []; // Not server side - this array is used to hold the images

socket.on('connection', (index, playerCoordinates) => 
{
    console.log('being called')

    for (let i = 0; i < playerCoordinates.length; i++) 
    {
        allPlayerObjects[i] = new component(30, 30, '/playerImage', playerCoordinates[i][0], playerCoordinates[i][1]);
    }
})

function startGame() {
    myGameArea.start();
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 800;
        this.canvas.height = 800;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.interval = setInterval(updateGameArea, 30);
        //this.interval = setInterval(updateCoords, 500);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },
    update : function(myPlayer)
    {
        ctx = myGameArea.context;
        // ctx.fillStyle = myPlayer.color;
        // ctx.fillRect(myPlayer.x, myPlayer.y, myPlayer.width, myPlayer.height);

        // THE BELOW COMMENTED OUT CODE WORKS, BUT SPRITE FLICKERS WHEN IN USE, SEE LAST FEW LINES OF SCRIPT FOR SOLUTION
        // myPlayer.image = new Image()
        // myPlayer.image.src = '/playerImage'
        // myPlayer.image.onload = function() {
        //     ctx.drawImage(assets.playerSprite, myPlayer.x, myPlayer.y, myPlayer.width, myPlayer.height);
        // }

        //ctx.drawImage(myPlayer.image, myPlayer.x, myPlayer.y, myPlayer.width, myPlayer.height);
        ctx.drawImage(myPlayer.image, myPlayer.x, myPlayer.y, myPlayer.width, myPlayer.height);
        //ctx.drawImage(assets.playerSprite, myPlayer.x, myPlayer.y, myPlayer.width, myPlayer.height);
    }
}

function component(width, height, color, x, y)
{
    this.image = new Image();
    this.image.src = color;
    this.width = width;
    this.height = height;
    this.x = x;
    this.y = y;
    this.speedX = 0;
    this.speedY = 0;
    /*  
    this.update = function() 
    {
        ctx = myGameArea.context;
        ctx.fillStyle = color;
        ctx.fillRect(this.x, this.y, this.width, this.height);
    }
    */
    this.newPos = function() {
        this.x += this.speedX;
        this.y += this.speedY;        
    }
}

let lastNum = 0;

function updateCoords()
{
    socket.emit('update');

    // THIS WON'T WORK FOR SOME REASON HENCE WHY UPDATE BULLET CODE IS IN UPDATE
    socket.emit('updateBullet');

    // GET LATEST POSITIONS AND LATEST VERSION OF THE LIST
    socket.on("update", (playerIndex, playerCoordinates, bulletArray) => {
        for (let i = 0; i < playerCoordinates.length; i++) 
        {
            allPlayerObjects[i] = new component(30, 30, '/playerImage', playerCoordinates[i][0], playerCoordinates[i][1]);
        }
        if (bulletArray.length == 1)
        {
            for (let i = 0; i < bulletArray[playerIndex].length; i++)
            {
                clientSideBulletArray[i] = new component(15, 30, '/playerBulletImage', bulletArray[playerIndex][i][0], bulletArray[playerIndex][i][1]);
            }
        }

        else
        {
            let count = 0;
            for (let i = 0; i < bulletArray.length; i++)
            {
                if (i == playerIndex)
                {
                    tempSprite = '/playerBulletImage';
                }

                else
                {
                    tempSprite = '/EnemyBullet';
                }
                for (let j = 0; j < bulletArray[i].length; j++)
                {
                    clientSideBulletArray[count] = new component(15, 30, tempSprite, bulletArray[i][j][0], bulletArray[i][j][1]);
                    count++;
                }
            }
        }
    });
}

function updateGameArea() {
    myGameArea.clear();
    let tempSprite;
    //bulletArray = [];

    socket.on("disconnection", (playerLocation) => {
        // Upon player disconnection, remove player entries from arrays
        allPlayerObjects.splice(playerLocation, 1)
    });

    updateCoords();

    /*
    // JAMES, THIS IS THE NEW SHOOT EVENT. ALL WE'RE DOING IS ADDING A NEW COMPONENT TO THE CLIENT SIDE ARRAY
    socket.on('shoot', (playerIndex, bulletArray) => {
        console.log(bulletArray[playerIndex].length);
        for (let i = 0; i < bulletArray[playerIndex].length; i++)
        {
            clientSideBulletArray[i] = new component(15, 30, '/playerBulletImage', bulletArray[playerIndex][i][0], bulletArray[playerIndex][i][1]);
        }
    });
    */

    // Update positions.
    for (let i = 0; i < allPlayerObjects.length; i++) 
    {
        allPlayerObjects[i].newPos();    
        //allPlayerObjects[i].update();
        myGameArea.update(allPlayerObjects[i]);
    }

    // HERE WE UPDATE THE BULLETS COORDINATES 
    for (let i = 0; i < clientSideBulletArray.length; i++)
    {
        //console.log(clientSideBulletArray)
        //clientSideBulletArray[i].y -= 2;
        myGameArea.update(clientSideBulletArray[i]);
    }

    /*
    // Update positions.
    for (let i = 0; i < bulletArray.length; i++) 
    {
        bulletArray[i].y -= 2;
        //allPlayerObjects[i].newPos();    
        //allPlayerObjects[i].update();
        myGameArea.update(bulletArray[i]);
    }
    */

}

function moveup() {
    socket.emit('player-move', 'y', -3) // 'player-move' event sends two arguments - Axis and Speed

    // The players index and new x,y values are returned from the server
    socket.on('player-update-coordinates', (playerIndex, playerCoordinates) => {
        // Update the appropriate player object with the new coordinates
        allPlayerObjects[playerIndex].x = playerCoordinates[0]
        allPlayerObjects[playerIndex].y = playerCoordinates[1]
    })
}

function movedown() {
    socket.emit('player-move', 'y', +3)
    socket.on('player-update-coordinates', (playerIndex, playerCoordinates) => {
        allPlayerObjects[playerIndex].x = playerCoordinates[0]
        allPlayerObjects[playerIndex].y = playerCoordinates[1]
    })
}

function moveleft() {
    socket.emit('player-move', 'x', -3)
    socket.on('player-update-coordinates', (playerIndex, playerCoordinates) => {
        allPlayerObjects[playerIndex].x = playerCoordinates[0]
        allPlayerObjects[playerIndex].y = playerCoordinates[1]
    })
}

function moveright() {
    socket.emit('player-move', 'x', +3)
    socket.on('player-update-coordinates', (playerIndex, playerCoordinates) => {
        allPlayerObjects[playerIndex].x = playerCoordinates[0]
        allPlayerObjects[playerIndex].y = playerCoordinates[1]
    })
}

function checkKey(e) 
{
    e = e || window.event;

    if (e.keyCode == '38') 
    {
        // up arrow
        moveup()
    }
    else if (e.keyCode == '40') 
    {
        // down arrow
        movedown()
    }
    else if (e.keyCode == '37') 
    {
        // left arrow
        moveleft()
    }
    else if (e.keyCode == '39') 
    {
        // right arrow
        moveright()
    }
    
    else if (e.keyCode == '32') 
    {
        console.log('space')
        socket.emit('shoot');

        /*
        socket.on('shoot', (playerIndex, bulletList) => {
            // space bar
            bulletArray[playerIndex].push(new component(8, 24, '/playerBulletImage', playerCoordinates[0] + ((allPlayerObjects[playerIndex].width - 8) / 2), playerCoordinates[1], "image"));
        })
        */
    }
}

const assets = {
  playerSprite: new Image(),
  bulletSprite: new Image(),
  EbulletSprite: new Image()
};

assets.playerSprite.onload = e => startGame(); // Once sprite image is loaded, start game (this prevents image flickering)
assets.playerSprite.src = '/playerImage';

assets.bulletSprite.onload = e => startGame(); // Once sprite image is loaded, start game (this prevents image flickering)
assets.bulletSprite.src = '/playerBulletImage';

assets.EbulletSprite.onload = e => startGame(); // Once sprite image is loaded, start game (this prevents image flickering)
assets.EbulletSprite.src = '/EnemyBullet';

document.onkeydown = checkKey;

</script>